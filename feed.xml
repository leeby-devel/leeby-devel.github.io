<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://leeby-devel.github.io/</id><title>작심삼일 블로그</title><subtitle>평범한 개발자의 평범한 기술 블로그 Back-End Engineer Specialized in Spring, Kotlin, Java, K8s, etc.</subtitle> <updated>2024-11-12T10:38:41+09:00</updated> <author> <name>leeby</name> <uri>https://leeby-devel.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://leeby-devel.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://leeby-devel.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2024 leeby </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>JEP 346 > unused (미사용) committed memory 를 OS 로 반환 (feat. 인프라 비용 절감)</title><link href="https://leeby-devel.github.io/posts/JEP346-unused-committed-memory-%EB%A5%BC-os-%EB%A1%9C-%EB%B0%98%ED%99%98/" rel="alternate" type="text/html" title="JEP 346 > unused (미사용) committed memory 를 OS 로 반환 (feat. 인프라 비용 절감)" /><published>2024-11-10T21:39:00+09:00</published> <updated>2024-11-12T10:38:06+09:00</updated> <id>https://leeby-devel.github.io/posts/JEP346-unused-committed-memory-%EB%A5%BC-os-%EB%A1%9C-%EB%B0%98%ED%99%98/</id> <content src="https://leeby-devel.github.io/posts/JEP346-unused-committed-memory-%EB%A5%BC-os-%EB%A1%9C-%EB%B0%98%ED%99%98/" /> <author> <name>leeby</name> </author> <category term="JVM" /> <category term="GC" /> <summary> 들어가며… 최근 회사에서 JDK, Spring Boot, Kotlin, Gradle 등 기반 시스템 버전 업그레이드하는 작업을 주도했다. 그 중 JDK 버전은 11 → 17, 17 → 21 두 단계로 진행할 계획이었고, 계획대로 JDK 17 부터 버전 업데이트를 했다. 업데이트 후 애플리케이션 메트릭을 살펴보는데 Heap 메모리 풋프린트가 이전과 다른 양상을 보였고, 이번 포스트에서 해당 내용을 다뤄보고자 한다. JVM Heap 메모리 먼저 JVM 힙메모리 상태에 대한 용어부터 짚고 가는 게 좋을 것 같다. Grafana JVM Micrometer 기준으로 JVM 힙 메모리는 used, committed, max (= reserved) 로 나뉜다. committed == max 인 상태 ... </summary> </entry> <entry><title>k8s 환경에서 패킷 캡쳐하는 방법 > tcpdump, wireshark</title><link href="https://leeby-devel.github.io/posts/k8s-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%ED%8C%A8%ED%82%B7-%EC%BA%A1%EC%B3%90%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/" rel="alternate" type="text/html" title="k8s 환경에서 패킷 캡쳐하는 방법 > tcpdump, wireshark" /><published>2024-10-28T23:52:00+09:00</published> <updated>2024-10-30T20:34:36+09:00</updated> <id>https://leeby-devel.github.io/posts/k8s-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%ED%8C%A8%ED%82%B7-%EC%BA%A1%EC%B3%90%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/</id> <content src="https://leeby-devel.github.io/posts/k8s-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%ED%8C%A8%ED%82%B7-%EC%BA%A1%EC%B3%90%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/" /> <author> <name>leeby</name> </author> <category term="Network" /> <summary> k8s 환경에서 서버를 운용하다보면 종종 파드에서 발생한 네트웍 이슈 트러블 슈팅을 위해 패킷 단위 분석이 필요한 경우가 있다. 이 때 tcpdump 로 생성한 덤프 파일을 시각화하기 위해 wireshark 를 활용한다. tcpdump 외에도 ksniff 같은 더 편리한 도구도 있다고 한다. 나중에 사용해 봐야겠다! 준비물 1. pod 에 tcpdump 설치 2. 로컬에 wireshark 설치 요약 1. pod &amp;gt; tcpdump 로 .pcap 파일 생성 2. 생성된 .pcap 파일을 kubectl cp 커맨드로 로컬에 복사 3. .pcap 파일을 wireshark 로 분석 1. 대상 pod 에서 덤프 파일 생성 $ tcpdump -i any -A -vvv -nn host &amp;lt;Desti... </summary> </entry> <entry><title>JVM 메모리 누수 > Native 메모리 > glibc malloc</title><link href="https://leeby-devel.github.io/posts/JVM-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-Native-%EB%A9%94%EB%AA%A8%EB%A6%AC-glibc-malloc/" rel="alternate" type="text/html" title="JVM 메모리 누수 > Native 메모리 > glibc malloc" /><published>2024-07-18T20:54:00+09:00</published> <updated>2024-10-30T20:48:26+09:00</updated> <id>https://leeby-devel.github.io/posts/JVM-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-Native-%EB%A9%94%EB%AA%A8%EB%A6%AC-glibc-malloc/</id> <content src="https://leeby-devel.github.io/posts/JVM-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-Native-%EB%A9%94%EB%AA%A8%EB%A6%AC-glibc-malloc/" /> <author> <name>leeby</name> </author> <category term="JVM" /> <summary> 몇 개월 전에 회사 애플리케이션에서 발생한 메모리 누수를 트러블 슈팅 &amp;amp; 픽스한 내용을 포스트로 다루었다. 누수를 잡아낸 후에도 미량이지만 애플리케이션 전체 메모리 사용량 (RSS 기준)이 계속해서 늘어나고 있었다. 원인을 파헤쳐보니 크리티컬한 내용은 아니나, GNU C 라이브러리 (glibc) 위에 구동되는 JVM 은 알게 모르게 영향을 받을 내용이라서 이곳에 그 내용을 공유해본다. 글의 내용이 glibc 를 사용하는 시스템을 전제로 하기 때문에 이 부분을 먼저 확인하시면 좋을 것 같습니다. 대표적으로 많이 사용하는 OS, JDK 벤더 기준으로 표를 구성해봤다. 잡담 adoptopenjdk/alpine 의 경우 alpine 의 기본 C 라이브러리인 musl 의 안정성 검토가 ... </summary> </entry> <entry><title>JVM 메모리 누수 > Heap > lettuce</title><link href="https://leeby-devel.github.io/posts/JVM-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-Heap-lettuce/" rel="alternate" type="text/html" title="JVM 메모리 누수 > Heap > lettuce" /><published>2024-04-12T21:00:00+09:00</published> <updated>2024-10-30T20:37:32+09:00</updated> <id>https://leeby-devel.github.io/posts/JVM-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-Heap-lettuce/</id> <content src="https://leeby-devel.github.io/posts/JVM-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-Heap-lettuce/" /> <author> <name>leeby</name> </author> <category term="JVM" /> <summary> 최근 회사 애플리케이션의 JVM 메모리 누수를 찾아낸 뒤 픽스했다. 과정을 정리해두면 메모리 누수를 또 찾고 있을 미래의 나에게도 도움이 될 것 같아 정리해본다. 트러블 슈팅 배경 애플리케이션 파드가 일정 시간 이상 에이징이 되면 RESTART 되고 있다. 사내 메트릭 분석 툴에 힙 히스토그램을 시계열로 분석할 수 있는 기능이 있어 이를 활용해봤다. 임의의 파드를 여러개 분석해 본 결과 long[] 타입 객체가 시간이 지나면서 힙에 계속 누적되는 현상을 알 수 있었는데, 문제는 이 객체들이 어디서부터 생성되는지다. 원인 파악 과정 우선 힙 덤프를 수행해야 한다. 운영 환경에서만 발생하는 문제이기 때문에 운영 환경 컨테이너에 힙 덤프를 수행해야 하는데, 힙 덤프를 수행하면 메모리 스냅샷을... </summary> </entry> <entry><title>JVM Container Awareness Bug (cgroup v2) > JDK 11.0.16</title><link href="https://leeby-devel.github.io/posts/JVM-Container-Awareness-Bug-cgroup-v2-JDK-11.0.16/" rel="alternate" type="text/html" title="JVM Container Awareness Bug (cgroup v2) > JDK 11.0.16" /><published>2022-11-05T16:54:00+09:00</published> <updated>2024-10-30T20:11:01+09:00</updated> <id>https://leeby-devel.github.io/posts/JVM-Container-Awareness-Bug-cgroup-v2-JDK-11.0.16/</id> <content src="https://leeby-devel.github.io/posts/JVM-Container-Awareness-Bug-cgroup-v2-JDK-11.0.16/" /> <author> <name>leeby</name> </author> <category term="JVM" /> <summary> 저처럼 글 읽기를 싫어하시는 분들을 위한 결론 Kubernetes 환경에서 JDK 11 을 사용중이라면 JDK 11.0.16 이상의 버전 사용을 권장한다. JDK 12 - 14 버전을 사용중이라면 15 이상의 버전 사용을 권장한다. 그렇지 않으면 소중한 Pod 가 OOMKilled 당할 수 있다. 특히 InitialRAMPercentage, MaxRAMPercentage 옵션을 사용한다면 꼭! 글이 깁니다. 다음 내용에 대해 구구절절 설명합니다. k8s 환경에서 JDK 11 구동시, 왜 JDK 11.0.16 이상의 버전을 사용해야 하는지 이 내용을 알아가게 된 과정 “적절한” 리소스 산정을 위한 여정… 최근 회사에서... </summary> </entry> </feed>
